# 动态规划 （算法导论 ch15）

[TOC]

### Introduction

1. 动态规划 通过组合子问题的解来求解原问题。对每个子问题只求解一次，将其解保存在一个表格中，避免不必要的计算工作。

2. 通常按照4个步骤来设计一个dp算法。

   - 刻画一个最优解的结构特征

   - 递归地定义最优解的值

   - 计算最优解的值，通常采用自底向上的方法

   - 利用计算出的信息构造一个最优解。

     （通常只需要前三步）

## 钢条切割

问题描述：给定一段长度为n英寸的钢条和一个价格表pi(i=1,2,...,n)，求切割钢条方案，是的销售收益rn最大。注意，如果长度为n英寸的钢条的价格pn足够大，最优解可能就是完全不需要切割

| 长度i  | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 价格pi | 1    | 5    | 8    | 9    | 10   | 17   | 17   | 20   | 24   | 30   |

n英寸

k段

ik表示第k段长度

pik表示ik长度的售价。 所有加起来就是rn。

rn表示n英寸钢材的最大收益。

 对于rn(n>=1)有如下公式
$$
r_n = max(p_n, r_1+r_{n-1}, r_2+r_{n-2},...,r_{n-1}+r_1 )
$$
注意到，为了求解规模为n的问题，我们先求解形式完全一样，但规模更小的子问题（**完成首次切割后，我们将两段钢条看成两个独立的钢条切割问题实例**）。再组合两个相关子问题的最优解，并在所有可能的两段切割方案中选取组合收益最大者，构成原来问题的最优解。

钢条切割问题满足**最优子结构**性质：问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解。

另一种更简单的递归求解方法：将钢条左边切割下长度为i的一段，只对右边剩下的长度为n-i的一段继续进行切割（递归求解），对左边的一段则不再进行切割。在此公式中，原问题的最优解只包含一个相关子问题（右端剩余部分）的解
$$
r_n = max(p_i + r_{n-i})(1<=i<=n)   (r_0 = 0)
$$
自顶向下递归实现：

```
CUT-ROD(p,n)
	if n==0
		return 0
	q = -INF
	for i=1 to n
		q = max(q,p[i] + CUT-ROD(p,n-i))
	return q
```

——以上程序的运行效率是极其低的。运行时间复杂度为2^n

**使用动态规划方法求解最优钢条切割问题**

付出额外的空间来节省计算时间。而时间上的节省是非常巨大的——指数到多项式时间。

动态规划有两种等价的实现方法：

1.  带备忘的自顶向下法(top-down with memoization) ： 此方法仍然按照自然地递归形式编写过程，但过程中会保存每个子问题的解（通常保存在一个数组或散列表中）。当需要一个子问题的解时，过程首先检查是否保存过此解。如果是，直接返回保存的值；否则，按通常方法计算这个子问题。
2. 自底向上法（bottom-up method）: 一般需要恰当定义子问题“规模”的概念，使得任何子问题的求解都只依赖于“更小的”子问题的求解。因而可以将子问题按规模排序，按从小到大的顺序求解。当求解到当前问题时，他的所有子问题都已经求解完成。

CUT-ROD加入备忘机制（**自顶向下**）：

```
MEMOIZATION-CUT-ROD(p,n):
	let r[0..n] be a new array
	for i = 0 to n
		r[i] = -INF
	return MEMORIZATION-CUT-ROD-AUX(p,n,r)

MEMORIZATION-CUT-ROD-AUX(p,n,r):
	if r[n] >= 0	//如果已经存在记录中，直接返回
		return r[n]
	if n == 0
	 	q = 0
	 else 
	 	q = -INF
	 	for i = 1 to n
	 		q = max(q,p[i]+MEMORIZATION-CUT-ROD-AUX(p,n-i,r))
	 r[n] = q	//记录
	 return q
```

**自底向上** 采用子问题的自然顺序，依次求解规模为j = 0,1, ... , n的子问题。

```
BOTTOM-UP-CUT-ROD(p,n):
	let r[0..n] be a new array
	r[0] = 0
	for j = 1 to n
		q = -INF
		for i = 1 to j
			q = max(q,p[i]+r[j-i])
		r[j] = q
	return r[n]
```

**子问题图 G=(V, E)** 准确地表达了一个DP问题涉及的子问题以及子问题之间的依赖关系。

- (x,y) : 求解问题x需要直接用到子问题y的最优解。
- 自顶向下的方法：子问题图可以看做是递归调用树的简化版
- 自底向上：对于所有的子问题，只有它依赖的所有子问题均已求解完成，才会求解它。
- 另外：通常，一个子问题的求解时间与子问题图中对应顶点的**出度**成正比，而子问题的数目等于子问题图的顶点数。

**重构解** ： 前面的算法只返回收益值，没有返回解本身（长度列表）。以下是BOTTOM-UP-CUT-ROD的扩展版本,**在求解规模为j的子问题时，将第一段钢条的最优切割长度i保存在s[j]中**

```
EXTENDED-BOTTOM-UP-CUT-ROD(p,n):
	let r[0..n] and s[0..n] be a new array
	r[0] = 0
	for j = 1 to n
		q = -INF
		for i = 1 to j
			if q < p[i] + r[j-i]
				q = p[i] + r[j-i]
				s[j] = i			
		r[j] = q
	return r and s
```

```
PRINT-CUT-ROD-SOLUTION(p,n):
	(r,s) = EXTENDED-BOTTOM-UP-CUT-ROD(p,n)
	while n>0
		print s[n]
		n = n-s[n]
```

## 矩阵链乘法

矩阵相乘算法：

```
MATRIX-MULTIPLY(A,B):
	if(A.columns != B.rows)
		error
	else let C be a new A.rows*B.columns matrix
		for i=1 to A.rows
			for j = 1 to B.columns
				Cij = 0
				for k =1 to A.columns     //A.columns == B.rows
					Cij = cij + Aik * Bkj
	return C
```

**完全括号化** ： 单一矩阵，或者是两个完全括号化的矩阵乘积链的积，且已外加括号

举例说明不同的加括号方式导致不同的计算代价：<A1, A2 ,A3> 分别是10X100、100X5、5X50 

((A1A2)A3)需要做 10X100x5 + 10X5x50 = 7500次乘法运算。

(A1(A2A3))需要做 100X5x50 + 10x100X50 = 75000次乘法运算。

**矩阵链乘法问题**：给定n个矩阵的链($A_1A_2...A_n$),矩阵$A_i$的大小是$p_{i-1} * p_i$ (1<=i<=n)，求完全括号化方案，使得计算乘积所需要标量乘法次数最少。

**注意**：确定最优计算顺序所花费的时间 要比随后真正进行矩阵相乘所节省的时间（如7500而不是75000）要少——否则确定最优计算顺序就没有意义了，还不如把这段时间用来计算（75000次）呢。

**计算括号化方案的数量** 穷举所有可能的括号化方案不是一个高效的方法。因为括号化方案的数量与n呈指数关系。

### 应用动态规划方法

通常按照4个步骤来设计一个dp算法。

- 刻画一个最优解的结构特征
- 递归地定义最优解的值
- 计算最优解的值，通常采用自底向上的方法
- 利用计算出的信息构造一个最优解。

#### 步骤1：最优括号化方案的结构特征

$A_iA_{i+1}...A_j$可以划分为两个子问题：$A_iA_{i+1}...A_k$ 和 $A_{k+1}A_{k+2}...A_j$（其中，i < j , i <= k < j）的最优括号化问题。求出子问题的最优解，然后将子问题的最优解结合起来。

必须保证在确定分割点时，已经考察了所有可能的划分点，这样可以保证不会遗漏最优解。

#### 步骤2：一个递归求解方案

**m[i,j]**表示$A_iA_{i+1}...A_j$的**所需要乘法次数的最小值**。计算$A_{1..n}$所需的最低代价就是m[1,n]次乘法。

- i == j 时，矩阵链中唯一包含矩阵$A_{i..i} = A_i$,因此不需要做任何标量乘法运算。所以m[i,i] = 0
- i < j , $m[i,j]=m[i,k]+m[k+1,j]+p_{i-1}p_kp_j (i<=k<j)$ 
  
- 矩阵$A_i$的大小是$p_{i-1} * p_i$ 
  
- k只有j-i种可能的取值，即k = i, i+1, ..., j-1.由于最优分割点必在其中，我们只需检查所有可能情况，找到最优解。所以递归求解公式为：

  $$ m[i,j]= \begin{cases} 0& \text{i=j}\\ \min \limits_{i<=k<j}\{m[i,k]+m[k+1,j]+p_{i-1}p_kp_j \}& \text{i<j} \end{cases} $$

- m[i,j]的值给出了子问题最优解的代价，但它并未提供足够的信息来构造最优解。为此用**s[i,j]**保存$A_iA_{i+1}...A_j$最优括号化方案的分割点位置k。

#### 步骤3：计算最优代价

采用自底向上表格法代替递归算法（会遇到很多重叠子问题，并且复杂度为指数型）来计算最优代价。

- 假定矩阵$A_i$ 的规模是$p_{i-1}*p_i(i=1, 2, ...,n)$ 。这个函数的参数是一个序列$p=<p_0,p_1,...,p_n>$
- 过程用一个辅助表m[1..n, 1..n]来保存代价m[i,j]，用另一个辅助表$s[1..n-1, 2..n]$记录最优值m[i, j]对应的分割点k，可以利用表s构造最优解。
- 确定计算m[i,j]时需要访问哪些其他表项。算法应该按长度递增的顺序求解矩阵链括号化问题，并按对应的顺序填写表m。

```
MATRIX_CHAIN_ORDER(p):
	n = p.length -1 
	let m[1..n,1..n] and s[1..n-1, 2..n] be new tables
	for i = 1 to n
		m[i,j] = 0
	for l = 2 to n
		for i = 1 to n-l+1
			j = i + l -1
			m[i,j] = INF
			for k = i to j -1
			q = m[i,k] + m[k+1,j] + P(i-1)pkpj
			if q < m[i,j]
				m[i,j] = q
				s[i,j] = k
	return m and s
```

#### 步骤4：构造最优解



## 动态规划原理

适合应用动态规划求解的最优化问题应该具备两个要素：**最优子结构和重叠子问题。**



## 最长公共子序列

[参考CSDN上的总结]( https://blog.csdn.net/so_geili/article/details/53737001 )

**子序列(subsequence)**：一个特定序列的子序列就是**将给定序列中零个或多个元素去掉后得到的结果(不改变元素间相对次序)**。例如序列<A,B,C,B,D,A,B>的子序列有：<A,B>、<B,C,A>、<A,B,C,D,A>等。

**公共子序列(common subsequence)**： 给定序列X和Y，序列Z是X的子序列，也是Y的子序列，则Z是X和Y的公共子序列。例如$X=<A,B,C,B,D,A,B>，Y=<B,D,C,A,B,A>$，那么序列$Z=<B,C,A>$为X和Y的公共子序列，其长度为3。但Z不是X和Y的最长公共子序列，而序列$<B,C,B,A>$和$<B,D,A,B>$也均为X和Y的最长公共子序列，长度为4，而X和Y不存在长度大于等于5的公共子序列。



**Longest-Common-Subsequence problem** 给定两个序列$X = <x_1,x_2,...,x_m>$和$Y=<y_1,y_2,...,y_n>$,求X和Y长度最长的公共子序列。 

#### 步骤一 刻画最长公共子序列的特征

**LCS的最优子结构** 令$X = <x_1,x_2,...,x_m>$和$Y=<y_1,y_2,...,y_n>$为两个序列，$Z=<z_1,z_2,...,z_k>$为X和Y的任意LCS.

1. 如果$x_m=y_n$，则$z_k=x_m=y_n$且$Z_{k-1}$是$X_{m-1}$和$Y_{n-1}$的一个LCS
2. 如果$x_m!=y_n$，那么$z_k!=x_m$意味着Z是$X_{m-1}$和Y的一个LCS
3. 如果$x_m!=y_n$，那么$z_k!=y_n$意味着Z是X和$Y_{n-1}$的一个LCS

从上面可以看出，两个序列的LCS包含两个序列的前缀的LCS。因此LCS问题具有**最优子结构**。步骤二可以看出其递归算法也具有**重叠子问题**。

#### 步骤二 一个递归解

- 如果$x_m=y_n$，我们应该求解$X_{m-1}和Y_{n-1}$的一个LCS1，将$x_m=y_n$追加到这个LCS1的末尾，就得到了X和Y的LCS.

- 如果$x_m！=y_n$，我们必须求解两个子问题：

  - $X_{m-1}$和Y的一个LCS
  - X和$Y_{n-1}$的一个LCS

  以上两个较长者为X和Y的一个LCS

建立最优解的递归式：定义c[i,j]表示$X_i 和Y_j$的LCS长度，可以得到如下公式

$$c[i,j]= \begin{cases} 0& \text{若i=0或j=0}\\ c[i-1,j-1]+1& \text{若i,j>0 且x_i=y_i}\\ \max\ \{c[i,j-1],c[i-1,j] \}& \text{若i,j>0且x_i!=y_j} \end{cases}  $$



#### 步骤三 计算LCS的长度

LCS_LENGTH将c[i,j]的值保存在表c[0..m,0..n]中，并按照**行主次序(row-major order)**计算表项：首先从左至右计算c的第一行，然后计算第二行，以此类推。过程还维护一个表b[1..m, 1..n]，帮助构造最优解。c[m,n]保存了X和Y的LCS长度。

![asdf](/image/15-8.jpg)



```
LCS_LENGTH(X,Y):
	m = X.length
	n = Y.length
	let b[1..m,1..n] and c[0..m,0..n] be new tables
	for i=1 to m	//第0行 第0列 设置为0
		c[i,0] = 0
	for j=0 to n
		c[0,j] = 0
	for i = 1 to m
		for j=1 to n
			if xi == yj  //实际上是i-1 j-1 因为i从1开始
				c[i,j] = c[i-1,j-1] + 1
				b[i,j] = "左上"
			elseif c[i-1,j] >= c[i,j-1]
				c[i,j] = c[i-1,j]
				b[i,j] = "上"
			else
				c[i,j] = c[i,j-1]
				b[i,j] = "左"
	return c and b
```



#### 步骤四 构造LCS

只需简单地从b[m,n]开始，并按箭头方向追踪下去即可。

**当b[i,j]遇到“左上”时，意味着$x_i=y_i$是LCS的一个元素。**

```
PRINT_LCS(b,X,i,j):
	if i==0 or j==0
		return 
	if b[i,j] == '左上'
		PRINT_LCS(b,X,i-1,j-1)
		print xi
	else if b[i,j]=="上"
		PRINT_LCS(b,X,i-1,j)
	else
		PRINT_LCS(b,X,i,j-1)
```

#### 算法改进

(见代码)

实现1中用了两个二维的表b和c，在时空开销上有改进的余地。我们完全可以去掉表b。因为每个$c[i][j]$只依赖于$c[i][j-1]、c[i-1][j-1]、c[i-1][j]$三项，当给定$c[i][j]$时，我们可以在O(1)的时间内判定出 $c[i][j]$ 使用了三项中的哪一项。从而节约了Θ(mn)的空间。

## 最优二叉搜索树



